<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head profile="http://gmpg.org/xfn/11">
	<title>SNA Projects Blog : Building a terabyte-scale data cycle at LinkedIn with Hadoop and Project Voldemort</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link rel="stylesheet" type="text/css" media="screen,projection" href="http://sna-projects.com/blog/wp-content/themes/barthelme/style.css" title="Barthelme" />
	<link rel="stylesheet" type="text/css" media="print" href="http://sna-projects.com/blog/wp-content/themes/barthelme/print.css" />
	<link rel="alternate" type="application/rss+xml" href="http://sna-projects.com/blog/feed/" title="SNA Projects Blog RSS feed" />
	<link rel="alternate" type="application/rss+xml" href="http://sna-projects.com/blog/comments/feed/" title="SNA Projects Blog comments RSS feed" />
	<link rel="pingback" href="http://sna-projects.com/blog/xmlrpc.php" />

<link rel="alternate" type="application/rss+xml" title="SNA Projects Blog &raquo; Building a terabyte-scale data cycle at LinkedIn with Hadoop and Project Voldemort Comments Feed" href="http://sna-projects.com/blog/2009/06/building-a-1-tb-data-cycle-at-linkedin-with-hadoop-and-project-voldemort/feed/" />
<script type='text/javascript' src='http://sna-projects.com/blog/wp-includes/js/l10n.js?ver=20101110'></script>
<script type='text/javascript' src='http://sna-projects.com/blog/wp-includes/js/jquery/jquery.js?ver=1.6.1'></script>
<script type='text/javascript' src='http://sna-projects.com/blog/wp-content/plugins/google-analyticator/external-tracking.min.js?ver=6.2'></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://sna-projects.com/blog/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://sna-projects.com/blog/wp-includes/wlwmanifest.xml" /> 
<link rel='index' title='SNA Projects Blog' href='http://sna-projects.com/blog/' />
<link rel='start' title='Added site documentation to Subversion' href='http://sna-projects.com/blog/2009/03/added-site-documentation-to-svn/' />
<link rel='prev' title='Moved to github' href='http://sna-projects.com/blog/2009/05/moved-to-github/' />
<link rel='next' title='Building Voldemort read-only stores with Hadoop' href='http://sna-projects.com/blog/2009/06/voldemort-and-hadoop/' />
<meta name="generator" content="WordPress 3.2.1" />
<link rel='canonical' href='http://sna-projects.com/blog/2009/06/building-a-1-tb-data-cycle-at-linkedin-with-hadoop-and-project-voldemort/' />
<link rel='shortlink' href='http://sna-projects.com/blog/?p=15' />

<style type="text/css" media="screen,projection">
/*<![CDATA[*/
/* CSS inserted by Barthelme theme options */
	body{font-family:arial,helvetica,sans-serif;font-size:85%;}
	div#content h2,div#content h3,div#content h4,div#content h5,div#content h6,body.archive div.archive-meta,body.attachment div.entry-content div.attachment-content p.attachment-name,body.home div#content div.entry-meta span,body.archive div#content div.entry-meta span,body.search div#content div.entry-meta span,body.single div.entry-date,body.single div.entry-meta,div#content blockquote,div.comments ol.commentlist li div.comment-meta,div.entry-content div.page-link,div.entry-content span.tag-links,body.page div.archive-meta,div.formcontainer form#commentform div.form-input input,div.formcontainer form#commentform div.form-textarea textarea#comment,input#s,div.entry-content div.entry-caption{font-family:arial,helvetica,sans-serif;}
	body div#content div.hentry{text-align:left;}
	body div#wrapper{width:auto;}
	div#header,div#header h1#blog-title a,div#header h1#blog-title a:link,div#header h1#blog-title a:visited{color:#FEFEFE;outline:none;text-decoration:none;}
	body div#header{background:#bbc8d9 url("http://sna-projects.com/blog/wp-content/themes/barthelme/images/header-img.php?upper=8999b0&lower=bbc8d9") repeat-x left top;}
/*]]>*/
</style>
<!-- Google Analytics Tracking by Google Analyticator 6.2: http://ronaldheft.com/code/analyticator/ -->
<script type="text/javascript">
	var analyticsFileTypes = [''];
	var analyticsEventTracking = 'enabled';
</script>
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-7818013-2']);
	_gaq.push(['_trackPageview']);
	_gaq.push(['_trackPageLoadTime']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>

</head>

<body class="wordpress y2012 m08 d07 h01 single s-y2009 s-m06 s-d15 s-h03 s-category-uncategorized s-author-jay">

<div id="wrapper">

	<div id="header" onclick="location.href='http://sna-projects.com/blog/';">
		<h1 id="blog-title"><a href="http://sna-projects.com/blog/" title="SNA Projects Blog">SNA Projects Blog</a></h1>
		<div id="blog-description">LinkedIn&#8217;s Search Network and Analytics team</div>
	</div><!-- #header -->
	
	<div class="access"><span class="content-access"><a href="#content" title="Skip to content">Skip to content</a></span></div>

<div id="globalnav"><ul id="menu"><li class="page_item_home home-link"><a href="http://sna-projects.com/blog/" title="SNA Projects Blog" rel="home">Home</a></li></ul></div>

	<div id="container">
		<div id="content" class="hfeed">


			<div id="post-15" class="hentry p1 post publish author-jay category-uncategorized y2009 m06 d15 h03">
				<div class="entry-date"><span class="meta-sep">{</span> <abbr class="published" title="2009-06-15T11:28:32+0000">2009 06 15</abbr> <span class="meta-sep">}</span></div>
				<h2 class="entry-title">Building a terabyte-scale data cycle at LinkedIn with Hadoop and Project Voldemort</h2>
				<div class="entry-content">
<p>Many of LinkedIn&#8217;s products are critically dependent on computationally intensive data mining algorithms. Examples of these include some modules like People You May Know, Viewers of This Profile Also Viewed, and much of the Job matching functionality that we give to people who post jobs on the site. To support these data-intensive products we have begun to move many of the largest offline processing jobs to Hadoop. These jobs form a fairly typical data cycle. Data is moved out of twenty or so online data storage systems (Oracle, MySQL, Voldemort, etc) as well as from our centralized logging service, where they go to offline systems like <a title="Hadoop" href="http://hadoop.apache.org/core/">Hadoop</a>, <a title="AsterData" href="http://www.asterdata.com">AsterData</a>, and our Oracle Data Warehouse. Moving all the data into centralized offline processing systems like these dramatically simplifies the implementation of complex algorithms which may use data from dozens of sources. Once data has been extracted a sequence of offline processing jobs are run on it. Finally the results are automatically loaded back into the live system to feed parts of the website. All offline data we produce is read-only once it goes live to avoid the complexity of merging the offline computations with online updates during the next run of this data processing cycle.</p>
<p>The difficulty in these systems comes with the fact that large amounts of data need to moved around every day. Thus although hundreds of gigabytes or terrabytes of data are not to difficult when sitting still in a storage system, the problem because much, much harder when it must be transformed to support quick lookups and moved between systems on a daily basis.</p>
<p>This post describes the system we built to deploy data to the live site using our key-value storage system, <a title="Project Voldemort" href="http://project-voldemort.com">Project Voldemort</a>.</p>
<p>Why do we end up with so much data? The size of the output is usually determined by the quantity of something on the site: we might compute something for each member profile, each question that gets asked, each news article that is posted, etc. These jobs may process a lot of data, especially if they involve any of the very large logging data streams, but the results, though large, are manageable. We have a second kind of job that is at least as common and produces results for each <em>pair</em> of users, or each <em>pair</em> of companies, or, say, the relationships <em>between</em> users and questions, or between the many other types of content on our site. As you might imagine the number of interesting pairs of items is much larger than the number of actual items (it isn&#8217;t as large as the square of the number of items, since most pairs aren&#8217;t interesting, but it is still huge). This seems to be a natural use case for social networks where the relationships are of central importance. Previously we did not need to confront this problem both because our data size was smaller, and also because our ability to produce large offline datasets was limited by computation constraints. Hadoop has been quite helpful in removing scalability problems in the offline portion of the system; but in doing so it creates a huge bottleneck in our ability to actually deliver data to the site. As is often the case, removing a bottleneck in one area creates a new bottleneck somewhere else.</p>
<p>To solve this problem we spent some time thinking about how to build support for large daily data cycles<a title="Project Voldemort" href="http://project-voldemort.com"></a>. Voldemort was designed to support fast, scalable read/write loads, and is already used in a number of systems at LinkedIn. It was not designed specifically with batch computation in mind, but it supports a pluggable architecture which allows the support of multiple storage engines in the same framework. This allows us to integrate our fast, failure-resistent online storage system, with the heavy offline data crunching running on Hadoop.</p>
<p>Here is a picture of what our world looks like:</p>
<p><img class="aligncenter size-full wp-image-54" title="linkedin_arch" src="http://project-voldemort.com/blog/wp-content/uploads/2009/06/linkedin_arch.png" alt="linkedin_arch" width="538" height="423" /></p>
<h2>Some existing approaches</h2>
<p>There are plenty of other ways to approach this problem, but no one we talked to had a good solution. We saw many variety of things being done, including pushing static text files by hand, FTPing giant XML files or doing JDBC batch inserts in an (Oracle) DB. None of these are really good approaches to the problem, since they typically have one of two common problems. The first is that the data transfer is centralized, creating an un-scalable bottleneck in the delivery of the data. The second is that the process of building the lookup index (generally a btree) is happening on the same live server that is serving lookups. This is a big problem since building a large index is a huge and computationally intense operation that may take hours, and by doing this on the live server we are effectively mixing this huge throughput-oriented operation with short-latency sensitive lookups, generally with poor results for your users.</p>
<h2>So what alternatives are there?</h2>
<p>The best online system for data lookups right now is <a title="Memcached" href="http://www.danga.com/memcached">memcached</a>. Memcached is stable and has excellent performance for common caching needs. The obvious problem with memcached are the &#8220;mem&#8221; and the &#8220;cache&#8221; parts. Memcached is all in memory so you need to squeeze all your data into memory to be able to serve it (which can be an expensive proposition if the generated data set is large). In addition memcached is a cache, so if you need to restart your servers then your data will disappear and need to be re-pushed! Another problem is the apparent lack of batch set operations. Without this the majority of time will inevitably be spent on unnecessary network round-trips no matter how efficiently we implement them. We could easily build a map reduce job to do this in parallel, but that only works around the underlying weakness in the per-node transfer rate.</p>
<p>The next best online system is <a title="MySQL" href="http://www.mysql.com">MySQL</a>. MySQL can avoid the one-round-trip per insert problem by doing batch inserts, but even that seems to give rather low throughput. MySQL&#8217;s InnoDB table format has too high space overhead to make it a real competitor. However MySQL has a very slim and simple MyISAM format. MyISAM isn&#8217;t used as much for normal read/write usage since it uses a global table write lockand lacks many transactional features, but this isn&#8217;t a problem for read-only usage since it is write-free. MySQL also supports an optimized &#8220;load data infile local&#8221; statement that provides bulk load capability. This is an extremely important feature for a disk-based storage format in this use case&#8211;building a 100GB index can not be done effectively as a sequence of b-tree updates that incrementally re-arrange data as the they go because the total IO casued by all the little updates is extremely high. To avoid this the tree needs to do a batch build that builds as much of the tree at once as possible, and this is exactly what the &#8220;load data&#8221; statement does. All-in-all MySQL is slim, quick, and generally the best off-the-shelf solution to this problem we have seen. Still to make this build effective you need a ton of memory, and it will lock the table for the duration of the build. This means that if you are running this on your live servers they will be extremely heavily worked for the duration of the load (which can easily take hours). Not to mention that MySQL provides little in the way of ability to parallelize this, making constructing a system on top of this a difficult proposition.</p>
<p>Clearly building an index like this is an offline operation and should not be done on a server that is serving live traffic as it will likely choke the CPU and IO resources from serving the live requests. In principle this is possible as MySQL (rather frighteningly) seems to allow you to just copy the files for a database into the database directory of a running server which will immediately make the table appear available without restarting. But this would mean maintaining a whole separate cluster of MySQL servers just for the purpose of index building as well as devising some way of parallelising this process. Finally a practical point is that you will likely have to write the data to disk multiple times&#8211;once to copy it to the server as a text file, then again as it is built as a database, and finally a third time if it copied to a live server (not to mention that fact that MySQL unfortunately seems to make its own internal copy of the data as well when you build the index to support its transactional requirements). Since the load data statement doesn&#8217;t seem to support compression, storing your data as CSV is a rather large blow-up. These things don&#8217;t seem like they should be a big problem, but when your 400GB data set turns into a 1,200GB dataset because all the numbers are in ASCII, and this file is then copied multiple times, that creates a serious problem.</p>
<h2>Requirements for a better solution</h2>
<p>These alternatives weren&#8217;t attractive, so we thought through what would be needed to do a good job with this problem. We came up with the following things:</p>
<ol>
<li><strong>Protect the live servers<em>.</em></strong> Uploading a new data set can&#8217;t impact the services relying on the data. We want the upload of new results to go as fast as possible but no faster. This means moving as much computation out of the online system as possible, and guaranteeing the live servers are not negetively impacted.</li>
<li><strong>Horizontal scalability at each step</strong>. Hadoop gives us a scalable approach to the build, and Voldemort gives a scalable system for the lookups. The trick is just ensuring that there is no centralized bottleneck in the process.</li>
<li><strong>Ability to rollback</strong>. Like any code, the processes that generates the data may have some kind of error or bug that leads to generating corrupt data, but unlike most code problems, fixing things may not be so quick. Since the processes may take many hours to run, and the data automatically goes live without human perusal, this kind of failure can leave us in a bad position. It may take hours to rerun (or for some very computationally intense processes, days), and we will could be stuck with the bad data until we manage to fix the bug, rerun everything, and re-push the fixed data. This is clearly unacceptable. As a result we would like to retain multiple copies of the data set, one for each of the last N pushes (where in the common case N = 1) so that we could revert to this known good state. This allows us to have a constant time rollback to a previous data set.</li>
<li><strong>Failure tolerance.</strong> This is where the Voldemort consistent hashing comes in to play&#8211;a server failure in the live system will redirect 1/K of that server&#8217;s traffic to each of the remaining servers without impacting the client. We also get similar failure tolerance in the build from using Hadoop.</li>
<li><strong>Support large ratios of data to RAM.</strong> The original problem we are trying to solve is that the data size is very large so we need to design accordingly. Improving performance in the case where the data is all in memory is not terribly valuable, the focus is on supporting a data size significantly larger than memory on each node.</li>
</ol>
<h2>Our approach</h2>
<p><a title="Bhupesh" href="http://www.linkedin.com/in/bhupeshbansal">Bhupesh</a>, <a title="Elias" href="http://www.linkedin.com/in/eliast">Elias</a>, and <a title="I" href="http://www.linkedin.com/in/jaykreps">I</a> toyed with solutions to these requirements, and here is the design we came up with.</p>
<p>One thing was clear, the Hadoop cluster is the natural place for the index build to occur. Hadoop is where the data is when the processing is done, and the goal of these machines is to run at full utilization so however computationally intense the build process is, it will not be a problem.</p>
<p>For the live system we wanted to adapt our key-value system, Voldemort. To do this we wanted to add an on-disk structure optimized for access to very large read only data sets we could deploy in batch. In particular we wanted some kind of simple file-based format we could stream to the servers to avoid doing many network round trips during the deployment. Ideally we should be able to deploy data at the rate possible by the network or disk system of the Voldemort and Hadoop clusters.</p>
<p>In early versions of the storage engine we toyed with different lookup and caching structures. But some simple benchmarking revealed this to be a rather academic exercise. The fundamental fact of filesystem access is that you may or may not be accessing the underlying disk depending on whether your request can be served by the OS&#8217;s pagecache or not.  A pagecache hit on an mmap&#8217;d file takes less than 250 nanoseconds but a page miss is around 5 milliseconds (a mere twenty thousand times slower). Any fancy data structure we build is likely to reside in-memory. Hence it would only help the lookups for things that would be in page cache anyway (since the process of loading them into memory would put them there) and so lookups on these would be fast no matter what. And worse this in-process lookup structure will likely steal memory from the pagecache to store its data, and since this will duplicate things in the pagecache it is extremely inefficient. Thus even if we manage to improve the lookup time for the things in our process memory, it is already quite low; and by doing so we use up memory that moves more requests out of the ns column and into the ms column. In short, <a title="Amdahl" href="http://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl</a> wins again.</p>
<p>To take advantage of this we have a very simple storage strategy that exploits the fact that our data doesn&#8217;t change&#8211;all we do is just mmap the entire data set into the process address space and access it there. This provides the lowest overhead caching possible, and makes use of the very efficient lookup structures in the operating system. Since our data is immutable, we don&#8217;t need to leave any space for growth and can tightly pack the data and index. Since the OS maintains the memory it can be very aggressive about this cache, and indeed it will attempt to fill all free RAM at all times with recently used pages. In comparison Java is a very inefficient user of memory since it must leave lots of extra space for garbage collection, etc. Plus anyone who has gotten intimate with Java GC tuning will not object to moving things out of the Java heap space.</p>
<h2>How data is stored</h2>
<p>Sometimes it&#8217;s nice to know what is going on under the covers. The data for a store named my_store would consist of the following files:</p>
<pre>my_store/
  version-0/
    0.index
    0.data
    ...
    n.index
    n.data
  version-1/
    0.index
    0.data
    ...</pre>
<p>As you can see a store is just a directory of simple files. The <em>.data</em> files contain variable length values and the <em>.index</em> files contain the lookup structure necessary to map keys to values. In principle only one <em>.index</em> and <em>.data</em> file would be needed, but since writing a file is inherently single-threaded we break it into chunks numbered 0 through <em>n</em> to allow greater parallelism in the build. These chunks are then grouped into version directories containing a complete version of the data, with <em>version-0</em> containing the current live data set.</p>
<p>Deploying a new version of the data consists of adding a new directory and renaming the existing ones. Storing multiple copies of the data is clearly a huge waste of space, but this is not too important as inactive files use no pagecache space just disk space. Small low latency reads on a huge data set will be largely seek bound, so we are going to need a lot of disk spindles no matter how we store things. Hard drive space is fairly cheap, so getting slightly larger disks to store additional copies is not a big problem.</p>
<p>To reduce the size of the file pointers and to work around limitations in Java&#8217;s mmap implementation, we limit chunk files to a maximum size of 2GB, so a reasonably sized store will consist of tens or hundreds of chunks per Voldemort node.</p>
<p>The order in which the values in the .data files are are stored is not important. Each value is prefixed by a 4 byte length indicating how many bytes to read. Each value is uniquely identified by the offset in the file at which its 4 byte length begins. The index contains 16 byte MD5 hashes of the keys along with the associated 4 byte position offset of the value in the data file. Because we hash keys, each key/value pair we store has a fixed overhead of exactly 24 bytes in addition to the length of the value itself. Furthermore this can be stored very efficiently as we can calculate the location of the <em>i</em>th index value as 20 * <em>i</em>. All lookups are positional; no internal pointers are needed within the index to locate entries.</p>
<p>The question is how to structure the keys in the index for quick lookups? A page- or block-organized tree is a good data structures if the data does not fit in memory. But this complicates both the lookups (which would need to be block aware), and the build process. In particular we want to perform our build in hadoop, which means that we will be limited to the amount of memory available to the mapper and reducer tasks which may leave only a few hundred megabytes for the build&#8211;if this does not fit our index data then we will have to perform some kind of external tree build. However on consideration we realized that since the index contains only 20 bytes per key even a very moderate amount of memory can hold several hundred million entries. Given this low overhead, very likely the whole index can (and should) be in memory (pagecache, not java heap), and so organizing the data by block or page is not really very important. As a result we greatly simplified our design&#8211;we just store the index entries in sorted order by md5 hash of the key.</p>
<p><img class="aligncenter size-full wp-image-25" title="data_format" src="http://project-voldemort.com/blog/wp-content/uploads/2009/05/data_format2.png" alt="data_format" width="397" height="607" /></p>
<p>A lookup in the store proceeds as follows:</p>
<ol>
<li>Calculate the MD5 of the key</li>
<li>The first 4 bytes of this md5, modulo the number of chunks, is the chunk number to search in</li>
<li> Do a binary search for the key md5 in that chunk&#8217;s .index file to get the position of the value in the data file</li>
<li>Finally read the appropriate number of bytes for the value from the data file starting at the given position</li>
</ol>
<p>The code for this storage engine is quite simple, only a few hundred lines, with the distribution and fault tolerance&#8211;the hard problems&#8211;being provided by the rest of Voldemort.</p>
<p>Binary search is not a very efficient algorithm for finding the location of the data. Most of the time this is not important since the index is in memory and so data access time dominates, but there are two cases that could be improved. The first is the case where all data and index fit entirely in memory. With very small keys, a chunk might have an index with, say, 100 million entries, which means a binary search does 27 key reads and comparisons and a single data read. In this case the cost of the search will dominate. Another suboptimal case is when we have an entirely uncached index. We explicitly transfer index files last in the data deployment to avoid this case, however in the case of rolling back to a previous index version it is unavoidable. To page the 100 million entry index for a chunk into memory will require 500k page faults no matter what the structure is. However it would be desirable to minimize the maximum number of page faults incurred on a given request to minimize the variance of the request time. In this case a page-organized tree, where each parent had 204 20 byte children, could do only log_204(100 million) = 4.5 page faults in the worst case and would be superior.</p>
<p>To resolve these cases we are working on an improved search algorithm which takes into account the uniformity of the key distribution, whch results from the fact that MD5 is (somewhat) cryptographically secure and so its keys are uniformly distributed. Rather than always beginning with a comparison to the middle entry such an algorithm would use the uniformity of the key distribution to compute the expected quantile of the key being looked up attempting to jump immediately to the correct location. If we can get a reliable implementation this promises to greatly improve the number of both page faults and comparisons needed in these corner cases.</p>
<h3>Index Building</h3>
<p>To build these store files we created two programs: a single-process command-line java program and also a distributed Hadoop-based store builder. The single process program uses a simple external sort to build the index files. Since this is a centralized process it is only useful for small data sets, testing, or one-time builds.</p>
<p>The Hadoop-based store builder is actually substantially simpler than the single-process builder as it leans heavily on Hadoop&#8217;s native capabilities to do its work. The store building processes proceeds as follows. An user-extensible Mapper extracts keys from the source data. This mapper can be parametrized to work with different <a title="InputFormat" href="http://hadoop.apache.org/core/docs/r0.18.3/api/org/apache/hadoop/mapred/InputFormat.html">InputFormat</a>s, and provides hooks to allow custom ways to construct the key and value from the data. A custom Hadoop <a title="Partitioner" href="http://hadoop.apache.org/core/docs/r0.18.3/api/org/apache/hadoop/mapred/Partitioner.html">Partitioner</a> then applies the Voldemort consistent hashing function to the keys, and assigns all keys mapped to a given node and chunk to a single reduce task. The shuffle phase of the map/reduce copies all values with the same destination node and chunk to the same reduce task. Thus each of the reduce tasks will create one .index and .data file for a given chunk on a particular node; and as a result the number of chunks specified in the configuration acts as a parameter to control the parallelism of the build. These values are then sorted by Hadoop in order to group them by key for reduce. Each reduce task copies the key/value pairs it is given into a pair of .index and .data files in sorted order to build its store chunk.</p>
<h2>Data deployment</h2>
<p>It is important that we be able to swap in a complete data set all at once without any downtime or impact to the live cluster. As described above, multiple data versions are kept in the <em>version-</em> subdirectories, but only <em>version-0</em> is used for serving data. Versions 1 through <em>n</em> are effectively backups. When a new data version is deployed, the version number of each existing data set is incremented, and the new set becomes the new <em>version-0</em>. To perform this swap a simple reader/writer lock is used to halt readers, each directory <em>version-i</em> is moved to <em>version-(i+1)</em>, and the new data is moved to <em>version-0</em> and the store is reopened and unlocked using this new dataset. Since only file renames are used, this is an O(1) operation, and in practice the whole procedure seems to complete in a few milliseconds irrespective of file size. The deleting of the <em>N</em>+1st version is prolonged until after the lock is released as delete may not be an O(1) operation, and may take over a minute on a filesystem that lack <a title="extents" href="http://en.wikipedia.org/wiki/Extents">extents</a> such as ext3.</p>
<p>The actual method for transferring data is pluggable. The original prototype used rsync in hope of efficiently supporting the transferring of diffs. However, this has two practical problems. The first was that the rsync diff calculation appears to be quite expensive, and half of the expensive calculation is done on the live server. Clearly if we want to do diffs, that too should be done on the batch system (Hadoop) not the live system (Voldemort). In fact due to this heavy calculation rsync was actually slower than just copying the whole file, even when the diff was rather small (though presumably much more network efficient). The more fundamental problem was that using rsync required copying the data out of HDFS to some local unix filesystem&#8211;which had better have enough space!&#8211;to be able to run rsync. This copying took as long as the data transfer to Voldemort, and meant we were copying the data twice.</p>
<p>To avoid these problems we switched from a push model to a pull model. It was important that we could schedule the transfer from the batch system to run automatically when the build completed successfully, so this took the form of a RESTful fetch command which triggers the Voldemort servers to fetch the data directly from HDFS. This mechanism is pluggable and a third party can provide an alternate implementation of the fetch command to support non-HDFS based mechanisms.</p>
<p>HDFS provides great throughput and seems to be able to max out the write capabilities of the Voldemort node. This is a blessing and a curse. Anyone who has lived with JDBC-based data transfer and seen it bottleneck on a measly few hundred KBs/sec will be overwhelmed with joy. But once again, removing performance problems in one area creates performance problems elsewhere: the high rate of data transfer to the live servers, even without any index building, can potentially starve live requests. However, in this model, where the server controls the pull, the Voldemort nodes can be configured to throttle itself to a fixed MB/sec limit so as not to overwhelm the I/O capabilities of the local Voldemort node. We have implemented a Voldemort configuration property, fetcher.max.bytes.per.sec, that controls this rate.</p>
<p>We have provided a driver program which initiates this fetch and swap procedure in parallel across a whole Voldemort cluster. In our tests this process can reach the I/O limit of either the Hadoop cluster or the Voldemort cluster.</p>
<p><img class="aligncenter size-full wp-image-23" title="store_build_process2" src="http://project-voldemort.com/blog/wp-content/uploads/2009/05/store_build_process2.png" alt="store_build_process2" width="486" height="274" /></p>
<h2>Some benchmarks</h2>
<p>There are two things to benchmark: the build time for a store in Hadoop and the request rate a node can sustain once live. We completed our benchmarks on EC2, since this is an easy way to get big clusters up and running for a quick test. Hopefully this will aid in making the results reproducible by others interested in testing different scenarios. We used extra large instances for both Hadoop and Voldemort as these most closely match our own hardware, and we used the <a title="Cloudera Hadoop AMI" href="http://www.cloudera.com/hadoop-ec2">Cloudera Hadoop AMI</a> to get the test cluster up and running quickly.</p>
<p>Benchmarking anything that involves disk access is notoriously difficult because of sensitivity to three factors:</p>
<ol>
<li> The ratio of data to memory</li>
<li>The performance of the disk subsystem, and</li>
<li>The entropy of the request stream</li>
</ol>
<p>The ratio of data to memory and the entropy of the request stream determine how many cache misses will be sustained, so these are critical. A random request stream is more or less un-cachable, but fortunately almost no real request streams are random. They tend to have strong temporal locality which is what page cache eviction algorithms exploit. So for our testing we can assume a large ratio of memory to disk, and test against a simulated request stream to get performance information.</p>
<p>The performance is still very sensitive to the quality of the disk subsystem used for the Voldemort nodes. A live system like this will do lots of quick seeks with relatively small reads and will likely be bound by the seek time of the hard drive and the number of drives. The drives on the EC2 machines are fairly weak and not configured with RAID so they are not optimal if you are purchasing hardware, and in our tests all the processes we benchmark are IO bound. To help make sense of all these variables we provide a comparison to MySQL&#8217;s performance on the same tasks on the same hardware.</p>
<p>We are not aware of an existing system that does full build and data deployment in parallel, so there no direct comparison possible. But any build process will consist of three stages: (1) partitioning the data into seperate sets for each destination nodes, (2) gathering all data for a given node, and (3) building the lookup structure for that node. We can only compare results for the actual build (i.e. part 3) with MySQL as there is no off-the-shelf method for (1) and (2).</p>
<p>For our tests the keys are integers in ascii form. The values are meaningless 1024 byte strings.</p>
<h3>Build Time</h3>
<p>We tested the Hadoop build for a variety of store sizes. This time is the complete build time including mapping the data out to the appropriate node-chunk, shuffling the data to the nodes that will do the build, and finally creating the store files. In general, the time was roughly evenly split between map, shuffle and reduce phases. The number of map and reduce tasks are a very important parameter, as experiments on a smaller data set showed that varying the number of tasks could change the build time by more than 25%, but due to time constraints no attempt was made to optimize these, we just used whatever defaults Hadoop produced. Here are the times taken:</p>
<ul>
<li>100GB: 28mins (400 mappers, 90 reducers)</li>
<li>512GB: 2hrs, 16mins (2313 mappers, 350 reducers)</li>
<li>1TB: 5hrs, 39mins (4608 mappers, 700 reducers)</li>
</ul>
<p>To compare the build time we created a RAID 10 array on a single extra large instance, and did a build using one node&#8217;s worth of data (100m keys). This  process to 6 hours and 3 minutes to build the 100GB table for single node. Assuming similar performance for partitioning and copying data around this would indicate a complete build time of almost 8 hours per destination node. But this comparison ignores the time necessary to extract the data from the source system and convert it to CSV format for loading. And, of course, this neglects the additional benefits of Hadoop for handling failures, dealing with slower nodes, etc.</p>
<p>In addition, this process is scalable: it can be run on a number of machines equal to the number of chunks (700 in our 1TB case) not the number of destination nodes (only 10).</p>
<p>Data transfer between the clusters happens at a steady rate bound by the disk or network. For our Amazon instances this is around 40MB/second.</p>
<h3>Online Performance</h3>
<p>Lookup time for a single Voldemort node compares well to a single MySQL instance as well. To test this we ran local tests against the 100GB per-node data from the 1 TB test. This test as well was run on an Amazon Extra Large instance with 15GB of RAM and the 4 ephemeral disks in a RAID 10 configuration. To run the tests we simulated we simulated 1 million requests from a real request stream recorded on our production system against each of storage systems. We see the following performance for 1 million requests against a single node:</p>
<table style="text-align: center; height: 119px;" border="0" width="301">
<tbody>
<tr>
<td></td>
<td><strong>MySQL</strong></td>
<td><strong>Voldemort</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Reqs per sec.</strong></td>
<td>727</td>
<td>1291</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Median req. time</strong></td>
<td>0.23 ms</td>
<td>0.05 ms</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Avg. req. time</strong></td>
<td>13.7 ms</td>
<td>7.7 ms</td>
</tr>
<tr>
<td>
<p style="text-align: left;"><strong>99th percentile req. time</strong></p>
</td>
<td>127.2 ms</td>
<td style="text-align: center;">100.7 ms</td>
</tr>
</tbody>
</table>
<p>These numbers are both for local requests with no network involved as the only intention is to benchmark the storage layer of these systems.</p>
<h2>How to actually use it</h2>
<p>The code is all checked in to <a title="github" href="http://github.com/voldemort/voldemort/tree/master">the main project repository on github</a>. The commands for building a store, and executing a swap can be found under the bin/ directory. Elias has written a <a href="http://project-voldemort.com/blog/2009/06/voldemort-and-hadoop">blog entry</a> on how to use these, and how he has put this system into action at <a href="http://www.lookery.com">Lookery</a>.</p>
<h2>Future work</h2>
<p>Nothing is ever finished, and below are a few of the ideas we didn&#8217;t quite get to. There are a lot of huge performance wins that exploit the immutable nature of the data that we have not yet taken advantage of. If any one is interested in playing with one of these problems here are a few ideas. LinkedIn is also looking for engineers to work on Project Voldemort full time, so if that sounds interesting <a href="http://www.linkedin.com/static?key=jobs_open">send us a resume</a>.</p>
<h4>Incremental data updates</h4>
<p>Despite the problems with rsync, incremental data pushes would be quite a big improvement for the case where the data changes by only 5%. This is a common case for a job that runs daily to recompute a large set of values. Getting efficient incremental performance is a harder problem than it sounds. We have never gotten a production system that will do this well in our past attempts: rsync didn&#8217;t seem to work well, MySQL&#8217;s load data performance is destroyed by pre-existing unique indexes, and Oracle insert/update is slower than a complete transfer and rebuild for anything but the most minor of changes.</p>
<p>There are two ways we can think of to support this. The first is the easiest to implement, and just consists of creating a diff file in much the same way that Unix diff or rsync , and using it in combination with the existing data on the live server to create the new set (rather than deploying everything each time). Since computing the diff turns out to be a very computationally intensive task for a large file, this work must be done in the offline Hadoop system. There is little point in trying to do incremental updates to the .index files as these are comparably small, and the changes are liable to be randomly interspersed throughout&#8211;so the diff won&#8217;t be much smaller than the original file. The .data files, however, do not have any inherent order so all the new data could be placed at the end of the file allowing for extremely efficient diffs. The &#8220;patch&#8221; could be applied in the process of doing the fetch, so that existing data segments would be read from the current <em>version-0</em> dataset and new segments would be read from the HDFS diff file.</p>
<p>The above strategy reduces the network transfer necessary and could be run in steady state each day. However it does still require writing the complete data set to disk for each deployment, rather than writing the smaller diff only. One strategy that could avoid this would be to create a seperate set of .index and .data files for each day and store each days data seperately on the live system. A naive lookup would have to check each of these directories from latest to oldest to retrieve a value. However a more sophisticated approach could keep a <a title="Bloom filter" href="http://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a> tracking which keys are in each day&#8217;s patch. This would give a quick way to determine which files need not be searched without actually performing the search (with high probability).</p>
<h4>Improved key hashing</h4>
<p>The consistent hashing algorithm Voldemort uses has the nice property that N copies of a key are more or less randomly distributed over the cluster. As a result a failed node redistributes load evenly to the remaining nodes. This is an essential property to be able to tolerate node failure. However this algorithm has the unfortunate property that the data on each machine is different, and as a result the data built for each machine is unique. This means that a replication factor of two, doubles the size of the data that must be built. A hashing algorithm tuned to this use case could avoid this problem by replicating at the chunk level. This would provide less fine-grained load distribution since each chunk of data would be fully replicated on N machines, but would avoid the blow-up due to replication factor. Voldemort supports pluggable hashing algorithms so this should not be too difficult to implement, but didn&#8217;t make the cut for our first attempt.</p>
<h4>Compression</h4>
<p>Because the data is known upfront and does not change, it is a good target for compression. LZO compression or another compression algorithm tuned towards fast decompression speed could improve performance by reducing IO.</p>
<h4>Better indexing</h4>
<p>Fancier index structures are another area for improvement. We think the probabilistic binary search will prove to be a very effective approach, but since we haven&#8217;t implemented it yet it is worth considering a few other approaches.</p>
<p>The idea of a 204-way page-aligned tree instead of a binary tree was mentioned above. Each set of 204 20-byte index entries would take 4080 bytes which with 16 bytes of padding would then be exactly page aligned for a 4k page. This would mean the first 4k page of the index file would contain the hottest entries, the next 204 entries would contain the next hottest, and so forth. Thus even though the number of comparison necessary to locate an entry would not asymptotically improve the maximum number of page faults necessary to do an index lookup would decrease substantially in practical terms (to 4 or 5 for a large index).</p>
<p>This is not the optimal tree structure for an immutable tree such as ours, though. A much better approach to this problem was brought up by Elias who was familiar with the literature on <a title="cache-oblivious algorithms" href="http://en.wikipedia.org/wiki/Cache-oblivious_algorithm">cache-oblivious algorithms</a>, and was aware of a cache-oblivious structure called a <a title="van Emde Boas tree" href="http://en.wikipedia.org/wiki/Van_Emde_Boas_tree">van Emde Boas tree</a>. Cache oblivious algorithms uses a data structure that recurses in on itself in a way that requires no assumptions or special treatment for page sizes or CPU caches to get optimal cache performance (under some reasonable assumptions). There is a well developed set of cache-oblivious data structures for dealing with disk-based tree lookups. These algorithms manage to nicely utilize CPU cache as well, all without explicit assumptions about the memory hierarchy.</p>
<p>Still another alternative would be an on-disk hash-based lookup structure. Such a structure can reduce the number of required comparisons in a lookup, though as with a tree, its creation could be difficult. The trade-off between extra space used in the hashing and the collision rate is well known. At the far end of this spectrum is the <a title="Minimal Perfect Hash" href="http://en.wikipedia.org/wiki/Minimal_perfect_hashing">minimal, perfect hash</a> which is a function that hashes a fixed set of <em>N</em> keys to exactly <em>N</em> hash table slots. This structure would seem to be optimal for the lookups since it guarantees that we will require no more than one lookup to find the location of the data (indeed we could entirely avoid storing the hash value itself reducing the index entry size to only 4 bytes for the position). The hash function itself requires only about 3 bits per entry to be stored once it has been found. Computing these hashes can be difficult, though, so only a real implementation would show if the superior lookup time was justified by the possible increase in build time. There is an off-the-shelf <a title="Sux4J" href="http://sux.dsi.unimi.it">MPH implementation</a> from the author of mg4j but we have not yet investigated the feasibility of this in much detail.</p>



				</div>

				<div class="entry-meta">
					<span class="entry-published">Posted by <span class="entry-author author vcard"><a class="url fn" href="http://sna-projects.com/blog/author/jay/" title="View all posts by jay">jay</a></span> on <abbr class="published" title="2009-06-15T11:28:32+0000">Monday, June 15, 2009, at 11:28 am</abbr>.</span> <span class="cat-links">Filed under <a href="http://sna-projects.com/blog/category/uncategorized/" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a>.</span> <span class="tag-links">Tagged <a href="http://sna-projects.com/blog/tag/hadoop/" rel="tag">hadoop</a>, <a href="http://sna-projects.com/blog/tag/linkedin/" rel="tag">linkedin</a>, <a href="http://sna-projects.com/blog/tag/read-only/" rel="tag">read-only</a>.</span> <span class="entry-rsslink">Follow any responses to this post with its <a href="http://sna-projects.com/blog/2009/06/building-a-1-tb-data-cycle-at-linkedin-with-hadoop-and-project-voldemort/feed/" title="Comments RSS to Building a terabyte-scale data cycle at LinkedIn with Hadoop and Project Voldemort" rel="alternate" type="application/rss+xml">comments RSS</a> feed.</span>
					<span class="entry-interact">Comments are closed, but you can <a href="http://sna-projects.com/blog/2009/06/building-a-1-tb-data-cycle-at-linkedin-with-hadoop-and-project-voldemort/trackback/" rel="trackback" title="Trackback URL for your post">trackback</a> from your blog.</span>
				</div>
			</div><!-- .post -->

<div class="comments">


	<h3 class="comment-header" id="numpingbacks"><span class="comment-count"><span class="meta-sep">{</span> 2 <span class="meta-sep">}</span></span> Trackbacks</h3>
	<ol id="pingbacks" class="commentlist">
		<li id="comment-7" class="pingback c-y2009 c-m06 c-d18 c-h04 alt c1">
			<div class="comment-meta">
				<span class="pingback-author vcard"><span class="fn n url org"><a href='http://fschiettecatte.wordpress.com/2009/06/18/hadoop-and-project-voldemort/' rel='external nofollow' class='url'>Hadoop and Project Voldemort &laquo; François Schiettecatte&#8217;s Blog</a></span></span>
				<span class="meta-sep">|</span>
				<span class="pingback-datetime"><abbr class="comment-published" title="2009-06-15T11:28:32+0000">June 18, 2009 at 12:48 pm</abbr></span>
				<span class="meta-sep">|</span>
				<span class="comment-permalink"><a href="#comment-7" title="Permalink to this comment">Permalink</a></span>
			</div>
						<p>[...] Software Development by François Schiettecatte on June 18, 2009   Great article in two parts (part 1, part 2) co-authored by Elias Torres on using Hadoop and Project Voldemort for managing very large [...]</p>
		</li>

		<li id="comment-1342" class="pingback c-y2010 c-m06 c-d16 c-h03 c2">
			<div class="comment-meta">
				<span class="pingback-author vcard"><span class="fn n url org"><a href='http://sna-projects.com/blog/2010/06/beating-binary-search/' rel='external nofollow' class='url'>SNA Projects Blog : Beating Binary Search</a></span></span>
				<span class="meta-sep">|</span>
				<span class="pingback-datetime"><abbr class="comment-published" title="2009-06-15T11:28:32+0000">June 16, 2010 at 11:55 pm</abbr></span>
				<span class="meta-sep">|</span>
				<span class="comment-permalink"><a href="#comment-1342" title="Permalink to this comment">Permalink</a></span>
			</div>
						<p>[...] as Voldemort stores. This allows us to support a big batch datacycle run out of Hadoop as described here. The data structure for these uses a large sorted index file to do lookups, what is stored in this [...]</p>
		</li>


	</ol><!-- #pingbacks .commentlist -->


</div><!-- .comments -->

			<div id="nav-below" class="navigation">
				<div class="nav-previous">&laquo; <a href="http://sna-projects.com/blog/2009/05/moved-to-github/" rel="prev">Moved to github</a></div>
				<div class="nav-next"><a href="http://sna-projects.com/blog/2009/06/voldemort-and-hadoop/" rel="next">Building Voldemort read-only stores with Hadoop</a> &raquo;</div>
			</div>

		</div><!-- #content .hfeed -->
	</div><!-- #container -->

	<div id="primary" class="sidebar">
		<ul>
<li id="linkcat-3" class="widget widget_links"><h3 class='widgettitle'>Links</h3>

	<ul class='xoxo blogroll'>
<li><a href="http://sna-projects.com/azkaban" title="Azkaban job manager.">Azkaban</a></li>
<li><a href="http://sna-projects.com/bobo" title="Fast faceted search">Bobo</a></li>
<li><a href="http://sna-projects.com/decomposer" title="Massive matrix decompositions">Decomposer</a></li>
<li><a href="http://sna-projects.com/kamikaze" title="Docset compression">Kamikaze</a></li>
<li><a href="http://sna-projects.com/norbert" title="Distributed cluster management and RPC.">Norbert</a></li>
<li><a href="http://project-voldemort.com" rel="me" title="The Project Voldemort Home Page">Project Voldemort</a></li>
<li><a href="http://sna-projects.com/sensei" title="Distributed search.">Sensei</a></li>
<li><a href="http://sna-projects.com/sna" title="LinkedIn&#8217;s SNA team">SNA Team</a></li>
<li><a href="http://sna-projects.com/zoie" title="Real-time search indexing">Zoie</a></li>

	</ul>
</li>

		<li id="rss_links" class="widget widget_rss_links">			<h3 class='widgettitle'>RSS</h3>
			<ul>
				<li><a href="http://sna-projects.com/blog/feed/" title="SNA Projects Blog Posts RSS feed" rel="alternate" type="application/rss+xml">All posts</a></li>
				<li><a href="http://sna-projects.com/blog/comments/feed/" title="SNA Projects Blog Comments RSS feed" rel="alternate" type="application/rss+xml">All comments</a></li>
			</ul>
		</li>
		<li id="recent-posts-2" class="widget widget_recent_entries">		<h3 class='widgettitle'>Recent Posts</h3>
		<ul>
				<li><a href="http://sna-projects.com/blog/2011/08/nodejs/" title="Tech Talk: Tom Hughes-Croucher (Joyent) &#8212; &#8220;Node.js at Scale&#8221;">Tech Talk: Tom Hughes-Croucher (Joyent) &#8212; &#8220;Node.js at Scale&#8221;</a></li>
				<li><a href="http://sna-projects.com/blog/2011/08/kafka/" title="Tech Talk: Neha Narkhede (LinkedIn) &#8212; Kafka, LinkedIn&#8217;s open-source distributed pub-sub messaging system">Tech Talk: Neha Narkhede (LinkedIn) &#8212; Kafka, LinkedIn&#8217;s open-source distributed pub-sub messaging system</a></li>
				<li><a href="http://sna-projects.com/blog/2011/07/game-dynamics/" title="Tech Talk: Rajat Paharia (Bunchball) &#8212; &#8220;Game Dynamics&#8221;">Tech Talk: Rajat Paharia (Bunchball) &#8212; &#8220;Game Dynamics&#8221;</a></li>
				<li><a href="http://sna-projects.com/blog/2011/07/hbase/" title="Tech Talk: Michael Stack (StumbleUpon) &#8212; &#8220;State of HBase&#8221;">Tech Talk: Michael Stack (StumbleUpon) &#8212; &#8220;State of HBase&#8221;</a></li>
				<li><a href="http://sna-projects.com/blog/2011/07/project-voldemort-090-release/" title="Project Voldemort 0.90 release">Project Voldemort 0.90 release</a></li>
				</ul>
		</li>

		</ul>
	</div>

	<div id="footer">
		<span id="copyright">&copy; 2012 <span class="vcard"><a class="url fn n" href="http://"><span class="given-name"></span> <span class="family-name"></span></a></span></span>
		<span class="meta-sep">|</span>
		<span id="generator-link">Thanks, <a href="http://wordpress.org/" title="WordPress" rel="generator">WordPress</a></span>
		<span class="meta-sep">|</span>
		<span id="theme-link"><a href="http://www.plaintxt.org/themes/barthelme/" title="Barthelme theme for WordPress" rel="follow designer">Barthelme</a> theme by <span class="vcard"><a class="url fn n" href="http://scottwallick.com/" title="scottwallick.com" rel="follow designer"><span class="given-name">Scott</span><span class="additional-name"> Allan</span><span class="family-name"> Wallick</span></a></span></span><!-- Theme design credit, that's all -->
		<span class="meta-sep">|</span>
		<span id="web-standards"> Standards Compliant <a href="http://validator.w3.org/check/referer" title="Valid XHTML">XHTML</a> &amp; <a href="http://jigsaw.w3.org/css-validator/validator?profile=css2&amp;warning=2&amp;uri=http://sna-projects.com/blog/wp-content/themes/barthelme/style.css" title="Valid CSS">CSS</a></span>
		<span class="meta-sep">|</span>
		<span id="footer-rss"> RSS <a href="http://sna-projects.com/blog/feed/" title="SNA Projects Blog RSS 2.0 Feed" rel="alternate" type="application/rss+xml">Posts</a> &amp; <a href="http://sna-projects.com/blog/comments/feed/" title="SNA Projects Blog Comments RSS 2.0 Feed" rel="alternate" type="application/rss+xml">Comments</a></span>
	</div><!-- #footer -->


</div><!-- #wrapper -->

</body><!-- end trasmission -->
</html>